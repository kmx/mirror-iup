<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Strict//EN">
<html>
<head>
<meta http-equiv="Content-Language" content="en-us">
<title>IupMatrix</title>
<link rel="stylesheet" type="text/css" href="../../style.css">
<style type="text/css">
.style1 {
	color: #0000FF;
	text-decoration: underline;
}
</style>
</head>
<body>
<div id="navigation">
  <ul>
    <li><a href="#Creation">Creation</a></li>
    <li><a href="#Attributes">Attributes</a></li>
    <li><a href="#Callbacks">Callbacks</a></li>
    <li><a href="#Notes">Notes</a></li>
    <li><a href="#Examples">Examples</a></li>
    <li><a href="#SeeAlso">See Also</a></li>
  </ul>
</div>

<h2>IupMatrix</h2>
<p>Creates a matrix of alphanumeric fields. 
  Therefore, all values of the matrixs fields are strings. The matrix is not a grid container like many systems 
  have. It inherits from 
<a href="../elem/iupcanvas.html">IupCanvas</a>.</p>
<p>This is an additional control that depends on the CD library. It is included 
in the 
<a href="../iupcontrols.html">Controls Library</a>.</p>
<p>It has two modes of operation: normal and callback mode. In normal mode string values are stored in attributes for 
  each cell. In callback mode these attributes are ignored and the cells are filled with strings returned by the &quot;VALUE_CB&quot; 
  callback. So the existance of this callback defines the mode the matrix will operate.</p>
<h3><a name="Creation">Creation</a></h3>
<div>
  <pre>Ihandle* IupMatrix(char *<strong>action_cb</strong>); [in C]
iup.matrix{} -&gt; (<strong>elem</strong>: ihandle) [in Lua]
matrix(<strong>action_cb</strong>) [in LED]</pre>
</div>
<p><strong>action_cb</strong>:
  Name of the action generated when the user 
  types something.</p>
<p>Returns the identifier of the created 
  matrix, or NULL if an error occurs.</p>
<h3><a name="Attributes">Attributes</a></h3>


<h4>Cell Attributes</h4>
<dl>
  <dd><a href="iupmatrix_attrib.html#L:C">L:C</a></dd>
  <dd><a href="iupmatrix_attrib.html#ALIGNMENTn">ALIGNMENTn</a></dd>
  <dd><a href="iupmatrix_attrib.html#BGCOLOR">BGCOLOR</a></dd>
  <dd><a href="iupmatrix_attrib.html#FGCOLOR">FGCOLOR</a></dd>
  <dd><a href="iupmatrix_attrib.html#FONT">FONT</a><br></dd>
  <dd><a href="iupmatrix_attrib.html#FRAMECOLOR">FRAMECOLOR</a></dd>
  <dd><a href="iupmatrix_attrib.html#VALUE">VALUE</a></dd>
</dl>
<h4>Column Attributes</h4>
<dl>
  <dd><a href="iupmatrix_attrib.html#RASTERWIDTHn">RASTERWIDTHn</a></dd>
  <dd><a href="iupmatrix_attrib.html#SORTSIGNn">SORTSIGNn</a></dd>
  <dd><a href="iupmatrix_attrib.html#WIDTHn">WIDTHn</a></dd>
  <dd><a href="iupmatrix_attrib.html#WIDTHDEF">WIDTHDEF</a></dd>
</dl>
<h4>Line Attributes</h4>
<dl>
  <dd><a href="iupmatrix_attrib.html#HEIGHTn">HEIGHTn</a></dd>
  <dd><a href="iupmatrix_attrib.html#HEIGHTDEF">HEIGHTDEF</a></dd>
  <dd><a href="iupmatrix_attrib.html#RASTERHEIGHTn">RASTERHEIGHTn</a></dd>
</dl>
<h4>Size Attributes</h4>
<dl>
  <dd><a href="iupmatrix_attrib.html#NUMCOL">NUMCOL</a></dd>
  <dd><a href="iupmatrix_attrib.html#NUMCOL_VISIBLE">NUMCOL_VISIBLE</a></dd>
  <dd><a href="iupmatrix_attrib.html#NUMLIN">NUMLIN</a></dd>
  <dd><a href="iupmatrix_attrib.html#NUMLIN_VISIBLE">NUMLIN_VISIBLE</a></dd>
</dl>
<h4>Mark Attributes</h4>
<dl>
  <dd><a href="iupmatrix_attrib.html#MARKAREA">MARKAREA</a></dd>
  <dd><a href="iupmatrix_attrib.html#MARK_MODE">MARK_MODE</a></dd>
  <dd><a href="iupmatrix_attrib.html#MARK">MARK</a></dd>
  <dd><a href="iupmatrix_attrib.html#MARKED">MARKED</a></dd>
  <dd><a href="iupmatrix_attrib.html#MARKMULTIPLE">MARKMULTIPLE</a></dd>
</dl>
<h4>Action Attributes</h4>
<dl>
  <dd><a href="iupmatrix_attrib.html#ADDCOL">ADDCOL</a></dd>
  <dd><a href="iupmatrix_attrib.html#ADDLIN">ADDLIN</a></dd>
  <dd><a href="iupmatrix_attrib.html#DELCOL">DELCOL</a></dd>
  <dd><a href="iupmatrix_attrib.html#DELLIN">DELLIN</a></dd>
  <dd><a href="iupmatrix_attrib.html#EDIT_MODE">EDIT_MODE</a></dd>
  <dd><a href="iupmatrix_attrib.html#ORIGIN">ORIGIN</a></dd>
  <dd><a href="iupmatrix_attrib.html#SHOW">SHOW</a></dd>
  <dd><a href="iupmatrix_attrib.html#REDRAW">REDRAW</a></dd>
</dl>
<h4>Text Edition Attributes</h4>
<dl>
  <dd><a href="iupmatrix_attrib.html#CARET">CARET</a></dd>
  <dd><a href="iupmatrix_attrib.html#MASKL:C">MASKL:C</a><br>
  <dd><a href="iupmatrix_attrib.html#MULTILINE">MULTILINE</a><br>
  <dd><a href="iupmatrix_attrib.html#SELECTION">SELECTION</a></dd>
</dl>
<h4>Canvas Attributes</h4>
<dl>
  <dd><a href="iupmatrix_attrib.html#BORDER">BORDER</a></dd>
  <dd><a href="iupmatrix_attrib.html#SCROLLBAR">SCROLLBAR</a></dd>
</dl>
<h4>General Attributes</h4>
<dl>
  <dd><a href="iupmatrix_attrib.html#CURSOR">CURSOR</a></dd>
  <dd><a href="iupmatrix_attrib.html#FOCUS_CELL">FOCUS_CELL</a></dd>
  <dd><a href="iupmatrix_attrib.html#HIDEFOCUS">HIDEFOCUS</a></dd>
  <dd><a href="iupmatrix_attrib.html#READONLY">READONLY</a></dd>
  <dd><a href="iupmatrix_attrib.html#RESIZEMATRIX">RESIZEMATRIX</a></dd>
</dl>
<h3><a name="Callbacks">Callbacks</a></h3>

<h4>Interaction</h4>
<p class="info">
<a href="iupmatrix_cb.html#ACTION_CB">ACTION_CB</a> -
    Action generated when a keyboard event 
    occurs.<a href="iupmatrix_cb.html#CLICK_CB"><br>
    CLICK_CB</a> -
    Action generated when any mouse button is 
    pressed over a cell.<a href="iupmatrix_cb.html#DRAW_CB"><br>
</a><a href="iupmatrix_cb.html#RELEASE_CB">RELEASE_CB</a> -
    Action generated when any mouse button is 
    released over a cell.<a href="iupmatrix_cb.html#DRAW_CB"><br>
</a><a href="iupmatrix_cb.html#MOUSEMOVE_CB">MOUSEMOVE_CB</a> -
    Action generated to notify the application 
    that the mouse has moved over the matrix.<br>
<a href="iupmatrix_cb.html#ENTERITEM_CB">ENTERITEM_CB</a> -
    Action generated when a matrix cell is 
    selected, becoming the current cell.<a href="iupmatrix_cb.html#LEAVEITEM_CB"><br>
    LEAVEITEM_CB</a> -
    Action generated when a cell is no longer 
    the current cell.<br>
<a href="iupmatrix_cb.html#SCROLL_CB">SCROLLTOP_CB</a> -
    Action generated when the matrix is scrolled 
    with the scrollbars or with the keyboard.</p>
<h4>Drawing</h4>
<p class="info">
<a href="iupmatrix_cb.html#BGCOLOR_CB">BGCOLOR_CB</a> -
    Action generated to retrieve the background 
    color of a cell when it needs to be redrawn. 
    <br>
    <a href="iupmatrix_cb.html#FGCOLOR_CB">FGCOLOR_CB</a> -
    Action generated to retrieve the foreground 
    color of a cell when it needs to be redrawn. 
    <br>
    <a href="iupmatrix_cb.html#FONT_CB">FONT_CB</a> -
    Action generated to retrieve the font 
    of a cell when it needs to be redrawn. 
    <br>
    <a href="iupmatrix_cb.html#DRAW_CB">DRAW_CB</a> -
    Action generated before the cell is drawn. 
    Allow a custom cell draw.<br>
<a href="iupmatrix_cb.html#DROPCHECK_CB">DROPCHECK_CB</a> -
    Action generated to determine if a dropdown 
    feedback should be shown.</p>
<h4>Editing</h4>
<p class="info">
<a href="iupmatrix_cb.html#DROP_CB">DROP_CB</a> -
    Action generated to determine if a text 
    field or a dropdown will be shown.<br>
<a href="iupmatrix_cb.html#DROPSELECT_CB">DROPSELECT_CB</a> -
    Action generated when an element in the 
    dropdown list is selected.<a href="iupmatrix_cb.html#EDITION_CB"><br>
    EDITION_CB</a> -
    Action generated when the current cell 
    enters or leaves the edition mode.</p>
<h4>Callback Mode</h4>
<p class="info">
<a href="iupmatrix_cb.html#VALUE_CB">VALUE_CB</a> -
    Action generated to verify the value of a 
    cell. 
    <br>
<a href="iupmatrix_cb.html#VALUE_EDIT_CB">VALUE_EDIT_CB</a> -
    Action generated to notify the application 
    that the value of a cell was edited. <br>
<a href="iupmatrix_cb.html#MARK_CB">MARK_CB</a> -
    Action generated to verify the selection 
    state of a cell. <a href="iupmatrix_cb.html#MARKEDIT_CB"><br>
    MARKEDIT_CB</a> -
    Action generated to notify the application 
    that the selection state of a cell was changed. 
  </p>
<h3>Additional Methods in Lua</h3>
<pre><strong>elem</strong>:setcell(<strong>lin, col</strong>: number, <strong>value</strong>: string)</pre>
<p>Modifies the text of a cell.</p>
<pre><strong>elem</strong>:getcell(<strong>lin, col</strong>: number) -&gt; (<strong>cell</strong>: string)</pre>
<p>Returns the text of a cell.</p>
<h3>Utility Functions </h3>
<p>These functions can be used to help set and get attributes from the matrix:</p>
<pre>void  IupMatSetAttribute(Ihandle*h, const char* a, int l, int c, char* v);
void  IupMatStoreAttribute(Ihandle* ih, const char* a, int l, int c, char* v);
char* IupMatGetAttribute(Ihandle* ih, const char* a, int l, int c);
int   IupMatGetInt(Ihandle* ih, const char* a, int l, int c);
float IupMatGetFloat(Ihandle* ih, const char* a, int l, int c);
void  IupMatSetfAttribute(Ihandle* ih, const char* a, int l, int c, const char* f, ...);</pre>
<p>They work just like the respective tradicional set and get functions. But the attribute string is complemented with 
  the L and C values. For ex:</p>
<pre>IupMatSetAttribute(ih, &quot;&quot; , 30, 10, v) = IupSetAttribute(n, &quot;30:10&quot;, v)
IupMatSetAttribute(ih, &quot;BGCOLOR&quot; , 30, 10, v) = IupSetAttribute(n, &quot;BGCOLOR30:10&quot;, v)
IupMatSetAttribute(ih, &quot;ALIGNMENT&quot; , 10, 0, v) = IupSetAttribute(n, &quot;ALIGNMENT10:0&quot;, v)  (*)
    (*) noticed that in this case the second value will be ignored.</pre>
<p>These functions are not available in Lua, since you can simply write:</p>
<pre>elem[&quot;bgcolor&quot;..l..&quot;:&quot;..c] = v
   or
elem[&quot;bgcolor30:10&quot;] = v</pre>
<h3><a name="Notes">Notes</a></h3>
<h4>Storage</h4>
<p>Before mapped to the native system, all attributes are stored in the hash 
table, independently from the size of the matrix or its operation mode. The 
action attributes like ADDLIN and DELCOL will NOT work.</p>
<p>When the matrix is mapped NOT in callback mode then the cell values and 
mark state are moved from the hash table to an internal storage at the matrix. 
Other cell attributes remains on the hash table. Cell values with indices 
greater than (NUMLIN,NUMCOL) are ignored. When mapped in callback mode cell 
values stored in the hash table are ignored.</p>
<h4>Size</h4>
<p>If you do not plan to use ADDLIN nor ADDCOL, and plan to set sparse cell 
values, then you must set NUMLIN and 
NUMCOL before mapping.</p>
<p>If you do not plan to set SIZE or RASTERSIZE, then set NUMCOL_VISIBLE and 
NUMLIN_VISIBLE so the Natural size will give better results. The Natural size is calculated using only the 
title cells size plus the size of NUMCOL_VISIBLE and NUMLIN_VISIBLE cells, but it is also affected if SCROLBAR is 
enabled. The natural height is the sum of the line heights from line 0 to 
NUMLIN_VISIBLE (inclusive), or line 0 plus the sum from line 
NUMLIN-NUMLIN_VISIBLE to NUMLIN if NUMLIN_VISIBLE_LAST is defined. The natural width is the sum of the column width 
from column 0 to NUMCOL_VISIBLE (inclusive), or column 0 plus the sum from 
column NUMCOL-NUMCOL_VISIBLE to NUMCOL if NUMCOL_VISIBLE_LAST is defined. Notice that since NUMCOL_VISIBLE 
and NUMLIN_VISIBLE do not include the titles then NUMCOL_VISIBLE+1 columns and 
NUMLIN_VISIBLE+1 lines are included in the sum.</p>
<p>The height of a line L depends on several attributes, first it checks the 
HEIGHT<em>L</em> attribute, then checks RASTERHEIGHT<em>L</em>, then the height 
of the title text for the line or if L=0 it searches for the heighest column 
title, if still could not define a height then if L!=0 it will use HEIGHTDEF, if 
L=0 then height will be 0. A similar approach is valid for the column width. The 
width of a column C first checks the WIDTH<em>C</em> attribute, then checks 
RASTERWIDTH<em>C</em>, then the width of the title text for the column or if C=0 
it searches for the widest line title, if still could not define a width then if 
C!=0 it will use WIDTHDEF, if C=0 then height will be 0.</p>
<p>When the scrollbars are enabled if the matrix area is greatter than the 
visible area then scroolbars will be displayed so the cells can be scrolled to 
be visible area. But the scrooling position is not free, the first cell at the 
top right corner is always aligned at the begining of the cell. So the scroll 
increment is a cell and it can not be broken. One problem that raises from this 
policy is that depending on the visible size the last cell may never be 
completely visible. So solve the matrix size must be ajusted so all the last 
cells are visible within the visible area, or the natural size can be computed 
using the last cells instead of the first cells using the attributes 
NUMCOL_VISIBLE_LAST and NUMLIN_VISIBLE_LAST.</p>
<p>Any cell can have more than one text line, just use the \n control character. 
Multiple text lines will be considered when calculating the title cell size 
based on its contents. The contents of ordinary cells (not a title) do not 
affect the cell size.</p>
<h4>Titles</h4>
<p>A matrix might have titles for lines and columns. Titles are not scrollable, 
non editable and presented with a different default background color. A matrix 
will have a line of titles if an attribute of the &quot;<em>L</em>:0&quot; type is defined, where L 
is a line number. It will have a column of titles if an attribute of the 
&quot;0:<em>C</em>&quot; type is defined, where C is a column number.</p>
<p>When allowed the
  width of a column can be changed holding and dragging its title right border, 
see RESIZEMATRIX. 
</p>
<h4>Callback Mode</h4>
<p>Very large matrices must use the callback 
  mode to set the values, and not the regular 
  value attributes of the cells. The idea is the following:</p>
<p>1 -
    Register the VALUE_CB callback<br>
    2 -
    No longer set the value of the cells. They 
    will be set one by one by the callback. Note that the values of the cells must now be stored by the user.<br>
    3 -
    If the matrix is editable, set the VALUE_EDIT_CB callback.<br>
    4 -
    When the matrix must be invalidated, use the REDRAW attribute to force a matrix redraw.</p>
<p>A negative aspect is that, when VALUE_CB is defined, after it is mapped the matrix never verifies attributes of type 
L:C again.</p>
<p>If VALUE_CB is defined and VALUE_EDIT_CB is not defined when the matrix is 
mapped then READONLY will be set to YES.</p>
<h4>Keyboard Navigation</h4>
<p>Keyboard navigation through the matrix cells outside the edition 
  mode is done by using the following keys:</p>
<ul>
  <li><strong>Arrows</strong>: Moves the focus to the next cell, according to 
    the arrows direction.</li>
  <li><strong>Page Up</strong> and <strong>Page Down</strong>: Moves a visible page up or down.</li>
  <li><strong>Home</strong>: Moves the focus to the fist column in the line.</li>
  <li><strong>Home</strong> <strong>Home</strong>: Moves the focus to the upper left corner of the 
    visible page.</li>
  <li><strong>Home</strong> <strong>Home</strong> <strong>Home</strong>: 
    Moves the focus to the upper left corner of the 
    first page of the matrix.</li>
  <li><strong>End</strong>: Moves the focus to the last column in the line.</li>
  <li><strong>End</strong> <strong>End</strong>: Moves the focus to the lower right corner of the 
    visible page.</li>
  <li><strong>End</strong> <strong>End</strong> <strong>End</strong>: Moves the focus to the lower right corner of the 
    last page in the matrix.</li>
</ul>
<p>Inside the <b>edition mode</b>, the 
  following keys are used 
  for a text field:</p>
<ul>
  <li><strong>Left, Right, Up and Down arrows</strong>: If the caret is at the extremes of the text 
    being edited then leave the edition mode and moves the focus accordingly.</li>
  <li><strong>Ctrl + arrows</strong>:
    Leave the edition mode and moves the focus 
    accordingly.</li>
</ul>
<p>When the matrix is outside the edition mode, pressing any character key makes the current key to enter in the edition 
  mode, the old text is replaced by the new one being typed. If <b>Enter</b> or 
<b>Space</b> is pressed, the current 
  cell enters the edition mode with the current text of the cell. If <b>Del</b> is pressed, the whole contents of the 
  cell will be 
  deleted. Double-clicking a cell also 
  enters the edition mode. In Motif, when start editing using a double click, the 
  user must click again to the edit control get the focus.</p>
<p>When the matrix is in the edition mode, to confirm the entered value, press 
<b>Enter</b>. 
  By pressing <b>Esc</b>, the previous value is restored. The cell will also leave the edition mode if the user clicked 
  in another cell or in another control, then the value will be confirmed. When pressing 
<b>Enter</b> 
  to confirm the value the focus goes to the cell bellow the current cell, if at the last line then the focus goes to 
  the cell on the left. The value confirmation depends on the
  EDITION_CB callback return code.</p>
<p>When using the keyboard to change the focus cell if the limit of the visible 
area is reached then the cells are automatically scrolled. Also if a cell 
partially visible is edited then first it is scrolled to the visible area.</p>
<h4>Marks</h4>
<p>When a mark mode is set the cells can be marked using mouse, if the keyboard is used all marks are cleared.</p>
<p>A marked cell will have its background attenuated to indicate that it is marked.</p>
<p>Cells can be selected individually or the marks can be restricted to lines and/or columns. Also multiple cells can 
  be marked simultaneously in continuous or in segmented areas. Lines and columns are marked only when the user clicks 
  in their respective titles. Continuous areas are marked holding and dragging the mouse or holding the 
<b>Shift</b> 
  key. Segmented areas are marked holding the <b>Ctrl</b> key.</p>
<h3><a name="Examples">Examples</a></h3>
<p><a href="../../examples/">Browse for Example Files</a></p>
<p>Creates a simple matrix with the values and 
  layout shown in the image below. There is also a menu that allows making some changes to the matrix.</p>
<p align="center">
<img src="iupmatrix.gif" alt="iupmatrx.gif (125Kb)" width="299" height="142"></p>
<h3><a name="SeeAlso">See Also</a></h3>

<p><a href="../elem/iupcanvas.html">IupCanvas</a></p>

</body>

</html>